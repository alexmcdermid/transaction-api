name: Deploy Backend (Prod)

on:
  workflow_dispatch:

jobs:
  deploy-prod:
    runs-on: ubuntu-latest
    environment: prod
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: Build and push backend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.PROD_ECR_TRANSACTION_API_REPO }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          docker build -t "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" -f Dockerfile .
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
      - name: Deploy backend to ECS
        env:
          ECS_CLUSTER: ${{ secrets.PROD_ECS_CLUSTER }}
          ECS_SERVICE: ${{ secrets.PROD_ECS_SERVICE }}
          ECS_TASK_FAMILY: ${{ secrets.PROD_ECS_TASK_FAMILY }}
          ECS_TASK_EXECUTION_ROLE_ARN: ${{ secrets.PROD_ECS_EXECUTION_ROLE_ARN }}
          ECS_TASK_ROLE_ARN: ${{ secrets.PROD_ECS_TASK_ROLE_ARN }}
          ECS_LOG_GROUP: ${{ secrets.PROD_ECS_LOG_GROUP }}
          ECS_TASK_CPU: "256"
          ECS_TASK_MEMORY: "512"
          AWS_REGION: ${{ secrets.AWS_REGION }}
          IMAGE: ${{ steps.login-ecr.outputs.registry }}/${{ secrets.PROD_ECR_TRANSACTION_API_REPO }}:${{ github.sha }}
          DB_HOST: ${{ secrets.PROD_DB_HOST }}
          DB_PORT: ${{ secrets.PROD_DB_PORT }}
          DB_NAME: ${{ secrets.PROD_DB_NAME }}
          DB_USERNAME: ${{ secrets.PROD_DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.PROD_DB_PASSWORD }}
          APP_CORS_ALLOWED_ORIGINS: ${{ secrets.PROD_CORS_ALLOWED_ORIGINS }}
          APP_SECURITY_JWT_ENABLED: "true"
          APP_SECURITY_ALLOW_HEADER_AUTH: "false"
          APP_SECURITY_JWT_ISSUER_URI: "https://accounts.google.com"
          APP_SECURITY_JWT_AUDIENCE: ${{ secrets.PROD_GOOGLE_CLIENT_ID }}
          APP_SECURITY_JWT_JWK_SET: ${{ secrets.PROD_GOOGLE_JWK_SET }}
        run: |
          set -euo pipefail
          python - <<'PY' > /tmp/task-def.json
          import json
          import os
          
          def required(name):
              value = os.environ.get(name, "")
              if not value:
                  raise SystemExit(f"Missing required env var: {name}")
              return value
          
          env_list = []
          def add_env(name, value, optional=False):
              if not value:
                  if optional:
                      return
                  raise SystemExit(f"Missing required env var: {name}")
              env_list.append({"name": name, "value": value})
          
          add_env("DB_HOST", required("DB_HOST"))
          add_env("DB_PORT", required("DB_PORT"))
          add_env("DB_NAME", required("DB_NAME"))
          add_env("DB_USERNAME", required("DB_USERNAME"))
          add_env("DB_PASSWORD", required("DB_PASSWORD"))
          add_env("APP_CORS_ALLOWED_ORIGINS", required("APP_CORS_ALLOWED_ORIGINS"))
          add_env("APP_SECURITY_JWT_ENABLED", required("APP_SECURITY_JWT_ENABLED"))
          add_env("APP_SECURITY_ALLOW_HEADER_AUTH", required("APP_SECURITY_ALLOW_HEADER_AUTH"))
          add_env("APP_SECURITY_JWT_ISSUER_URI", required("APP_SECURITY_JWT_ISSUER_URI"))
          add_env("APP_SECURITY_JWT_AUDIENCE", required("APP_SECURITY_JWT_AUDIENCE"))
          add_env("APP_SECURITY_JWT_JWK_SET", os.environ.get("APP_SECURITY_JWT_JWK_SET", ""), optional=True)
          add_env("SERVER_PORT", "80")
          
          container = {
              "name": "Main",
              "image": required("IMAGE"),
              "essential": True,
              "portMappings": [{"containerPort": 80, "protocol": "tcp"}],
              "environment": env_list,
          }
          
          log_group = os.environ.get("ECS_LOG_GROUP", "")
          if log_group:
              container["logConfiguration"] = {
                  "logDriver": "awslogs",
                  "options": {
                      "awslogs-group": log_group,
                      "awslogs-region": required("AWS_REGION"),
                      "awslogs-stream-prefix": "transaction-api",
                  },
              }
          
          task_def = {
              "family": required("ECS_TASK_FAMILY"),
              "networkMode": "awsvpc",
              "requiresCompatibilities": ["FARGATE"],
              "cpu": os.environ.get("ECS_TASK_CPU", "256"),
              "memory": os.environ.get("ECS_TASK_MEMORY", "512"),
              "executionRoleArn": required("ECS_TASK_EXECUTION_ROLE_ARN"),
              "containerDefinitions": [container],
          }
          
          task_role = os.environ.get("ECS_TASK_ROLE_ARN", "")
          if task_role:
              task_def["taskRoleArn"] = task_role
          
          print(json.dumps(task_def))
          PY
          
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file:///tmp/task-def.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          aws ecs update-service \
            --cluster "${ECS_CLUSTER}" \
            --service "${ECS_SERVICE}" \
            --task-definition "${TASK_DEF_ARN}"
          
          aws ecs wait services-stable \
            --cluster "${ECS_CLUSTER}" \
            --services "${ECS_SERVICE}" \
            --max-attempts 120 \
            --delay 15
